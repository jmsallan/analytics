---
title: "Join operators in dplyr"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Joining dataframes

`dplyr` includes a set of functions for joining dataframes with a relational structure. This means that we have columns in each table (not necessarily with the same name), that can relate the contents of the two tables.

```{r, message=FALSE}
library(dplyr)
```


## Mutating joins

**Mutating joins** return a data frame with the columns of two data frames *x* and *y*:

![the joining operators](hMKKt.jpg)

* **inner join**: returns all rows from *x* where there are matching values in *y*. If there are multiple matches between *x* and *y*, all combination of the matches are returned.

* **full (outer) join**: returns all rows from both *x* and *y*.  Where there are not matching values, returns NA for the ones missing.

* **left join**: returns all rows from **x**. Rows of *x* with no match in *y* will have NA values in the *y* columns. If there are multiple matches between *x* and *y*, all combination of the matches are returned.

* **right join**: returns all rows from **y**. Rows of *y* with no match in *x* will have NA values in the *x* columns. If there are multiple matches, all combinations are returned.

These four mutating joins are implemented in dplyr with the **inner_join**, **full_join**, **left_join** and **right_join** functions.

To illustrate the result of the four mutating joins, we use a minimal example from the `dplyr`package:

```{r}
band_members
band_instruments
```

The columns used to build the join are, by default, the ones with the same column name, in this case the `name` columns. Let's do a inner and and outer join:

```{r}
inner_join(band_members, band_instruments)
full_join(band_members, band_instruments)
```


And now let's perform a left and right join:

```{r}
right_join(band_members, band_instruments)
left_join(band_members, band_instruments)
```

## Filtering joins

Filtering joins are used to retain (filter) rows of *x* with matching values in *y*, or without matching values in *y*. In dplyr, we use the **semi_join** and **anti_join** functions to do the first and second filtering, respectively:

```{r}
semi_join(band_members, band_instruments)
anti_join(band_members, band_instruments)
```

## Specifying joining columns with by

If the names of joining columns are different in each data frame, we use parameter **by**:

```{r}
inner_join(band_members, band_instruments2, by=c("name" = "artist"))
```

Note that in the result, the name of the joining column of the left-hand side data frame is retained.



